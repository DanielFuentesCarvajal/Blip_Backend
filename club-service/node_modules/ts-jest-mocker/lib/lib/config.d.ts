export declare type MockConfig = RequireAtLeastOne<MockConfigInternal>;
export interface MockConfigInternal {
    /**
     * The list of methods/functions (names) which will be excluded from mocking while creating mock.
     */
    excludeMethodNames?: Array<string | Symbol>;
    /**
     * The list of methods/functions (names) which will be included for mocking while creating mock.
     */
    includeMethodNames?: Array<string | Symbol>;
    /**
     * If set to <i>true</i>, methods that are called, but not mocked by user, will throw an error and fail tests.
     */
    failIfMockNotProvided?: boolean;
}
export interface MergedConfig {
    excludeMethodNames: Set<string | Symbol>;
    includeMethodNames: Set<string | Symbol>;
    failIfMockNotProvided: boolean;
}
export interface GlobalTsJestMocker {
    tsJestMockerConfig?: MockConfig;
}
export declare namespace MergedConfig {
    /**
     * Merges local or global config with default values.
     */
    function merge(defaultConfig: Required<MockConfig>, localConfig?: MockConfig): MergedConfig;
}
export declare type RequireAtLeastOne<T> = {
    [K in keyof T]-?: Required<Pick<T, K>> & Partial<Omit<T, K>>;
}[keyof T];
export declare namespace TsJestMocker {
    /**
     * Sets global {@link MockConfig}.
     *
     * @param config The TS Jest Mocker configuration that will be used for all mocks by default.
     */
    function setConfig(config: MockConfig | undefined): void;
    /**
     * Gets global {@link MockConfig}.
     */
    function getConfig(): MockConfig | undefined;
    /**
     * Type Guard to check whether specified Object is {@link MockConfig}.
     */
    function isTsJestMockerConfig(obj: Record<any, any>): obj is MockConfig;
}
